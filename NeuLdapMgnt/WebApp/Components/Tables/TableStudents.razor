@inherits LayoutComponentBase

<ConfirmDialog @ref="dialog" />

<Modal @ref="modalEdit" title="Edit selected students" ModalType="ModalType.Warning" Size="ModalSize.Large" IsScrollable="true" OnHidden="ToggleEditMode">
	<BodyTemplate>
		<div class="fw-bold mb-2">This action can not be reverted!</div>
		<div class="mb-2">
			<Switch @ref="switchEditIsActive" @bind-Value="editIsInactive" Label="Set status to [Inactive]?" />
		</div>
		<div class="form-floating">
			<InputSelect class="form-select rounded" id="class-select" @bind-Value="editedClass">
				<option value="@string.Empty" disabled>Select class</option>
				@foreach (var cls in LocalDbService.Classes)
				{
					<option value="@cls">@cls</option>
				}
			</InputSelect>
			<label for="class-select">New Class</label>
		</div>
	</BodyTemplate>
	<FooterTemplate>
		<ButtonDelete Text="Delete" OnClick="DeleteSelected" />
		<ButtonCancel Text="Cancel" OnClick="HideModalEdit" />
		<ButtonSave Text="Save" OnClick="UpdateSelected" />
	</FooterTemplate>
</Modal>

	<div class="d-flex justify-content-between align-items-center g-2 mb-3">
		<div class="d-flex flex-grow-1 flex-md-grow-0">
			<div class="input-group">
				<label class="input-group-text" for="searchbar"><i class="bi bi-funnel"></i></label>
				<div class="form-floating flex-grow-1">
					<input type="search"
						   class="form-control rounded-0 rounded-end"
						   id="searchbar"
						   @oninput="UpdateSearchQuery"
						   @bind-value="searchQuery" />
					<label for="searchbar">OM, Name, Class</label>
				</div>
			</div>
		</div>
		<div class="ms-2">
			@if (isEditing)
			{
				<Button Color="ButtonColor.Warning" Outline="true" Disabled="isEditing">
					<Spinner Type="SpinnerType.Dots" Color="SpinnerColor.Warning" />
				</Button>
			}
			else
			{
				<ButtonEdit OnClick="ShowModalEdit" IsDisabled="isStudentSelected" Text="Edit selected" />
			}
		</div>
	</div>

	<div class="table-students table-responsive rounded px-1 border flex-fill">
		<table class="table table-striped table-borderless align-middle">
			<thead class="sticky-top">
				<tr class="rounded">
					<th class="user-select-none text-wrap col-1" role="button" @onclick="SelectAllStudents">
						@if (!AreAllFilteredStudentsSelected())
						{
							<span>Select all (@selectedStudents.Count/@filteredStudents.Count)</span>
						}
						else
						{
							<span>Deselect all (@selectedStudents.Count/@filteredStudents.Count)</span>
						}
					</th>
					<th class="user-select-none" role="button" @onclick="@(() => SortTable("Id"))">
						OM
						@if (sortBy == "Id")
						{
							<i class="bi @GetSortIcon(isAscending)"></i>
						}
						else
						{
							<i class="bi bi-chevron-expand"></i>
						}
					</th>
					<th class="user-select-none" role="button" @onclick="@(() => SortTable("Name"))">
						Name
						@if (sortBy == "Name")
						{
							<i class="bi @GetSortIcon(isAscending)"></i>
						}
						else
						{
							<i class="bi bi-chevron-expand"></i>
						}
					</th>
					<th class="user-select-none" role="button" @onclick="@(() => SortTable("Class"))">
						Class
						@if (sortBy == "Class")
						{
							<i class="bi @GetSortIcon(isAscending)"></i>
						}
						else
						{
							<i class="bi bi-chevron-expand"></i>
						}
					</th>
					<th class="user-select-none text-end">Inspect |  Edit</th>
				</tr>
			</thead>
			<tbody>
				@foreach (var student in filteredStudents)
				{
					<tr>
						<td class="rounded-start">
							<input class="form-check-input"
								   type="checkbox"
								   checked="@selectedStudents.Contains(student)"
								   @onchange="() => SelectStudent(student)" />
						</td>
						<td>@student.Id</td>
						<td>@student.FullName</td>
						<td>@student.Class</td>
						<td class="text-end rounded-end">
							<ButtonInspectStudent OnClick="InspectStudent" Student="@student" />
						</td>
					</tr>
				}
			</tbody>
		</table>
	</div>


@code {
	[Parameter]
	public List<Student> Students { get; set; } = new();

	[Parameter]
	public EventCallback<IEnumerable<Student>> OnStudentsDelete { get; set; }

	[Parameter]
	public EventCallback<(IEnumerable<Student>, string?, bool)> OnStudentsUpdate { get; set; }

	private List<Student> filteredStudents = new();
	private List<Student> selectedStudents = new();
	private Timer? searchDelayTimer;

	private ConfirmDialog dialog = default!;
	private Modal modalEdit = default!;
	private Modal modalErrors = default!;

	private string? searchQuery = string.Empty;
	private string sortBy = "Id";

	private bool isAscending = true;
	private bool isLoading = false;
	private bool isEditing = false;
	private bool isStudentSelected => !selectedStudents.Any();

	private string editedClass = string.Empty;
	private bool editIsInactive = false;
	private Switch switchEditIsActive = default!;

	protected override void OnInitialized()
	{
		filteredStudents = Students.ToList();
		searchDelayTimer = new Timer(Callback, null, Timeout.Infinite, Timeout.Infinite);
	}

	private async Task UpdateSelected()
	{
		if (OnStudentsUpdate.HasDelegate)
		{
			await OnStudentsUpdate.InvokeAsync((selectedStudents, editedClass, editIsInactive));
			await HideModalEdit();
		}
	}

	private async Task DeleteSelected()
	{
		if (!selectedStudents.Any()) return;

		var parameters = new Dictionary<string, object>();
		parameters.Add("List", selectedStudents.Select(x => $"[{x.Class}] {x.FullName}").ToList());

		var confirmation = await dialog.ShowAsync<CustomList>(
			title: $"Are you sure you want to delete [{selectedStudents.Count}] students?",
			parameters: parameters,
			confirmDialogOptions: DialogOptions.Delete()
		);

		if (!confirmation) return;

		if (OnStudentsDelete.HasDelegate)
		{
			await OnStudentsDelete.InvokeAsync(selectedStudents);
			await HideModalEdit();
		}
	}

	private void SelectStudent(Student student)
	{
		if (selectedStudents.Contains(student))
		{
			selectedStudents.Remove(student);
		}
		else
		{
			selectedStudents.Add(student);
		}
	}

	private void SelectAllStudents()
	{
		if (AreAllFilteredStudentsSelected())
		{
			selectedStudents.Clear();
		}
		else
		{
			selectedStudents = filteredStudents.ToList();
		}
	}

	private void GetFilteredStudents()
	{
		if (string.IsNullOrWhiteSpace(searchQuery))
		{
			filteredStudents = Students.ToList();
		}
		else
		{
			filteredStudents = Students
				.Where(x => x.Id.ToString().Contains(searchQuery, StringComparison.OrdinalIgnoreCase)
							|| x.FullName.Contains(searchQuery, StringComparison.OrdinalIgnoreCase)
							|| x.Class.Contains(searchQuery, StringComparison.OrdinalIgnoreCase))
				.ToList();
		}

		selectedStudents.Clear();
	}

	private void Callback(object? state)
	{
		InvokeAsync(() =>
		{
			GetFilteredStudents();
			StateHasChanged();
		});
	}

	private void UpdateSearchQuery(ChangeEventArgs e)
	{
		searchQuery = e.Value?.ToString();
		searchDelayTimer?.Change(400, Timeout.Infinite);
	}

	private bool AreAllFilteredStudentsSelected()
	{
		return selectedStudents.Count > 0
			&& selectedStudents.Count.Equals(filteredStudents.Count);
	}

	private void ShowStudent(string id) => NavManager.NavigateTo($"/students/{id}");

	private void InspectStudent(Student student) => ShowStudent(student.Id.ToString());

	private string GetSortIcon(bool asc) => asc ? "bi-sort-up" : "bi-sort-down";

	private void SortTable(string propertyName)
	{
		if (sortBy == propertyName)
		{
			isAscending = !isAscending;
		}
		else
		{
			sortBy = propertyName;
			isAscending = true;
		}

		switch (propertyName)
		{
			case "Id":
				filteredStudents = isAscending
					? filteredStudents.OrderBy(x => x.Id).ToList()
					: filteredStudents.OrderByDescending(x => x.Id).ToList();
				break;

			case "Name":
				filteredStudents = isAscending
					? filteredStudents.OrderBy(x => x.FullName).ToList()
					: filteredStudents.OrderByDescending(x => x.FullName).ToList();
				break;

			case "Class":
				filteredStudents = isAscending
					? filteredStudents
							.OrderBy(x => Utils.GetClassOrderValue(x.Class))
							.ToList()
					: filteredStudents
							.OrderByDescending(x => Utils.GetClassOrderValue(x.Class))
							.ToList();
				break;

			default:
				break;
		}

		StateHasChanged();
	}

	private async Task ShowModalEdit()
	{
		if (modalEdit is null) return;
		await modalEdit.ShowAsync();
		ToggleEditMode();
	}

	private async Task HideModalEdit()
	{
		if (modalEdit is null) return;
		await modalEdit.HideAsync();
	}

	private async Task ShowModalErrorList()
	{
		if (modalErrors is null) return;
		await modalErrors.ShowAsync();
	}

	private async Task HideModalErrorList()
	{
		if (modalErrors is null) return;
		await modalErrors.HideAsync();

		if (modalEdit is null) return;
		await modalEdit.HideAsync();
	}

	private void ToggleEditMode() => isEditing = !isEditing;

	public void Dispose() => searchDelayTimer?.Dispose();
}

